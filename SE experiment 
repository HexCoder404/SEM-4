

## **EXPERIMENT NO. 01**

**Title:** Application of at least two traditional process models

**Aim:** To apply and compare two traditional software process models (e.g., Waterfall Model and V-Model) to understand their implementation, advantages, and limitations in the context of a software development project.[1]

**System Software/Instruments/Equipment's Requirements:** Pen/Paper or Google Docs[1]

**Theory:**

Traditional software process models provide a structured approach to software development, ensuring that each phase of the project is completed before moving on to the next. These models are characterized by their sequential or iterative nature and are typically used in projects where requirements are well understood and unlikely to change significantly.[1]

**1. Waterfall Model:**
- The Waterfall Model is a linear and sequential approach where each phase must be completed before the next begins. The phases include Requirement Analysis, System Design, Implementation, Integration and Testing, Deployment, and Maintenance.[1]
- **Advantages:** Simple and easy to understand, structured approach, well-suited for projects with clear requirements.[1]
- **Disadvantages:** Inflexible to changes, late discovery of defects, not suitable for complex or long-term projects.[1]

**2. V-Model (Verification and Validation Model):**
- The V-Model is an extension of the Waterfall Model where each development phase is associated with a corresponding testing phase, forming a V shape. The left side of the V represents development activities, while the right side represents testing activities.[1]
- **Advantages:** Emphasizes testing at each stage, early defect detection, improves project quality.[1]
- **Disadvantages:** Rigid structure, not adaptable to changes, can be costly if changes are required later in the project.[1]

***

## **EXPERIMENT NO. 02**

**Title:** Application of the Agile Process Models

**Aim:** To understand and apply Agile process models, specifically Scrum and Extreme Programming (XP), in the context of a software development project.[1]

**System Software/Instruments/Equipment's Requirements:** (Not specified in document)[1]

**Theory:**

Agile process models are iterative and incremental approaches to software development that emphasize flexibility, customer collaboration, and rapid delivery of functional software. Unlike traditional models, Agile processes are adaptive, accommodating changes even late in the development cycle, and focus on delivering small, working pieces of software frequently.[1]

**1. Scrum:**
- Scrum is an Agile framework that divides the project into small, manageable units called sprints, typically lasting 2-4 weeks. It emphasizes teamwork, accountability, and iterative progress toward a well-defined goal.[1]
- **Roles in Scrum:** Product Owner, Scrum Master, and Development Team.[1]
- **Artifacts:** Product Backlog, Sprint Backlog, and Increment.[1]
- **Events:** Sprint Planning, Daily Scrum, Sprint Review, and Sprint Retrospective.[1]
- **Advantages:** High flexibility, continuous feedback, regular delivery of increments.[1]
- **Disadvantages:** Requires strong team collaboration and discipline, can be challenging to scale for large projects.[1]

**2. Extreme Programming (XP):**
- XP is an Agile methodology that focuses on technical excellence and frequent releases of software in short development cycles. It encourages practices like pair programming, test-driven development (TDD), and continuous integration.[1]
- **Core Practices:** Pair Programming, TDD, Continuous Integration, Refactoring, Simple Design, and Collective Code Ownership.[1]
- **Advantages:** Improves software quality, encourages code simplicity, and ensures that changes can be made easily and rapidly.[1]
- **Disadvantages:** Can be resource-intensive, requires a high level of developer skill and commitment.[1]

**Program:**

1. **Select a Case Study:** Choose a software project with evolving requirements, such as an E-commerce website or a Task Management Application.[1]

2. **Application of Scrum:**
   - Sprint Planning: Define the scope of the sprint, prioritize the backlog, and assign tasks.[1]
   - Daily Scrum: Conduct daily stand-up meetings to discuss progress, impediments, and next steps.[1]
   - Sprint Review: Demonstrate the working increment to stakeholders and gather feedback.[1]
   - Sprint Retrospective: Reflect on the sprint process and identify areas for improvement.[1]

***

## **EXPERIMENT NO. 03**

**Title:** Preparation of Software Requirement Specification (SRS) Document in IEEE Format

**Aim:** To understand the structure and components of a Software Requirement Specification (SRS) document for a given software project.[1]

**System Software/Instruments/Equipment's Requirements:** Google Docs[1]

**Theory:**

A Software Requirement Specification (SRS) document is a comprehensive description of a software system to be developed. It includes both functional and non-functional requirements and serves as a critical document in the software development lifecycle, ensuring that all stakeholders have a clear and agreed-upon understanding of what the software will do.[1]

The IEEE standard provides guidelines for writing an SRS document, emphasizing clarity, completeness, and consistency. The SRS document typically includes the following sections:[1]

**1. Introduction:**
- Purpose: Describes the purpose of the SRS document.[1]
- Scope: Defines the boundaries of the software product.[1]
- Definitions, Acronyms, and Abbreviations: Provides definitions of terms used in the document.[1]
- References: Lists any external documents referenced in the SRS.[1]
- Overview: Gives a high-level overview of the content and structure of the document.[1]

**2. Overall Description:**
- Product Perspective: Describes the context and origin of the product.[1]
- Product Functions: Provides a summary of the main functionalities.[1]
- User Characteristics: Describes the users of the system.[1]
- Constraints: Lists any constraints imposed on the design or implementation.[1]
- Assumptions and Dependencies: Documents any assumptions or dependencies.[1]

**3. Specific Requirements:**
- Functional Requirements: Detailed description of the system's functionalities.[1]
- External Interface Requirements: Describes interfaces with other systems.[1]
- System Features: Breaks down system features and corresponding requirements.[1]
- Non-functional Requirements: Defines performance, security, reliability, and other quality attributes.[1]
- Logical Database Requirements: Specifies database requirements.[1]
- Design Constraints: Lists constraints such as standards compliance or hardware limitations.[1]

The SRS document serves as a foundation for system design, coding, testing, and maintenance. It is crucial for ensuring that the final product meets user expectations and fulfills the project's objectives.[1]

**Steps:**

1. **Select a Case Study:** Choose a software project, such as an Online Banking System, Hospital Management System, or E-commerce Platform.[1]

2. **Gather Requirements:** Conduct requirement elicitation sessions with stakeholders, including interviews, questionnaires, and brainstorming sessions.[1]

3. **Structure the SRS Document:** Follow the IEEE standard to organize the SRS document. Ensure that all sections are included and properly formatted.[1]

4. **Document Functional Requirements:** Detail the functionalities that the system must perform. Use use cases or user stories to describe interactions between users and the system.[1]

5. **Document Non-functional Requirements:** Specify requirements related to performance, usability, reliability, security, and other quality attributes.[1]

6. **Review and Validate:** Review the SRS document with stakeholders to ensure completeness, correctness, and clarity. Make necessary revisions based on feedback.[1]

7. **Finalization:** Finalize the SRS document and prepare it for submission. Ensure that it is clear, concise, and free of ambiguities.[1]

***

## **EXPERIMENT NO. 04**

**Title:** Structured Data Flow Analysis

**Aim:** To perform structured data flow analysis for a software system, using Data Flow Diagrams (DFDs) to model the flow of information and to understand how data is processed within the system.[1]

**System Software/Instruments/Equipment's Requirements:** (Not specified in document)[1]

**Theory:**

Structured data flow analysis is a technique used in software engineering to represent how data moves through a system and how it is processed at different stages. The primary tool for this analysis is the Data Flow Diagram (DFD), which provides a graphical representation of the flow of data within a system.[1]

**Data Flow Diagram (DFD):**
- **Purpose:** DFDs are used to visualize the flow of information in a system, showing the sources, destinations, storage, and transformations of data.[1]
- **Components:**
  - Processes: Represent activities that transform data within the system.[1]
  - Data Stores: Depict places where data is stored.[1]
  - Data Flows: Indicate the movement of data between processes, data stores, and external entities.[1]
  - External Entities: Represent sources or destinations of data that are outside the system's scope.[1]

**Levels of DFDs:**
- **Level 0 DFD (Context Diagram):** Provides a high-level overview of the system, showing the system's boundaries and interactions with external entities.[1]
- **Level 1 DFD:** Breaks down the main process into sub-processes, providing more detail on how data flows within the system.[1]
- **Level 2 and Beyond:** Further decompose processes into more granular sub-processes, if necessary.[1]

DFDs are essential in understanding the logical flow of information, identifying potential inefficiencies, and ensuring that all data interactions are accounted for in the system's design.[1]

**Steps:**

1. **Select a Case Study:** Choose a software project, such as a Student Information System, Inventory Management System, or Online Reservation System.[1]

2. **Requirement Gathering:** Conduct an initial analysis to gather detailed requirements related to the flow of data within the chosen system.[1]

3. **Develop a Context Diagram (Level 0 DFD):**
   - Identify the main process of the system and its interactions with external entities.[1]
   - Draw the Level 0 DFD to represent these interactions.[1]

4. **Develop Level 1 DFD:**
   - Break down the main process into sub-processes.[1]
   - Identify data stores and data flows between these sub-processes and external entities.[1]
   - Draw the Level 1 DFD to illustrate these details.[1]

5. **Develop Level 2 DFD (if necessary):**
   - Further decompose sub-processes identified in Level 1 to provide additional detail.[1]
   - Draw Level 2 DFD to represent these more granular processes.[1]

6. **Validation and Review:** Review the DFDs with stakeholders to ensure they accurately represent the system's data flow. Make any necessary revisions based on feedback.[1]

7. **Final Documentation:** Compile the DFDs along with descriptions of each component, ensuring that the document is clear and well-organized.[1]

***

## **EXPERIMENT NO. 05**

**Title:** Use of Metrics to Estimate the Cost

**Aim:** To apply software metrics to estimate the cost of software development projects, using various techniques and tools to evaluate and predict project expenses based on different metrics.[1]

**System Software/Instruments/Equipment's Requirements:** Google Docs[1]

**Theory:**

Software cost estimation is a critical aspect of project management that involves predicting the amount of resources, time, and money required to complete a software development project. Metrics play a crucial role in estimating costs by providing quantitative measures of various aspects of the software development process.[1]

**Software Metrics:**

**1. Function Points:**
- **Definition:** Function Points measure the functionality delivered by the software based on its features, such as inputs, outputs, and user interactions.[1]
- **Use:** Function Points can be used to estimate effort and cost based on historical data and productivity rates.[1]

**2. Lines of Code (LOC):**
- **Definition:** LOC measures the total number of lines in the source code of a software application.[1]
- **Use:** LOC can be used to estimate the effort required based on average coding productivity rates and cost per line of code.[1]

**3. COCOMO Model:**
- **Definition:** The COnstructive COst MOdel (COCOMO) is a parametric model that estimates the cost based on various project attributes, such as size, complexity, and development environment.[1]
- **Use:** COCOMO provides a cost estimation formula that incorporates different cost drivers to predict the project cost.[1]

**4. Function Point Analysis (FPA):**
- **Definition:** FPA measures the functionality provided to users based on function points, adjusting for complexity and productivity.[1]
- **Use:** FPA helps in estimating the cost by evaluating the number of function points and applying productivity rates.[1]

**Steps:**

1. Select a software project for which you want to estimate the cost.[1]

2. Identify the metrics that will be used for estimation (e.g., LOC, FP, COCOMO, UCP).[1]

3. Collect data related to the metrics. For example:[1]
   - Count the estimated lines of code for the project.[1]
   - Identify and quantify function points based on user requirements.[1]
   - Gather necessary data for COCOMO, such as the size of the project in LOC or FP, and adjust for factors like complexity and experience.[1]

4. Apply the chosen metric models to estimate the cost.[1]
   - For LOC: Use historical data to estimate cost per line of code.[1]
   - For FP: Use a standard FP-to-cost conversion formula based on historical project data.[1]
   - For COCOMO: Use the COCOMO formula: Effort (PM) = a × (Size)^b × E[1]

5. Calculate the total estimated cost using the metrics data collected.[1]

6. Analyze the results to determine the accuracy and reliability of the estimation.[1]

***

## **EXPERIMENT NO. 06**

**Title:** Scheduling & Tracking of the Project

**Aim:** To understand and apply techniques for scheduling and tracking software development projects, using project management tools to create project timelines, track progress, and manage resources.[1]

**System Software/Instruments/Equipment's Requirements:** (Not specified in document)[1]

**Theory:**

Effective scheduling and tracking are crucial for successful project management, ensuring that software projects are completed on time, within budget, and according to specifications. This involves creating a detailed project schedule, monitoring progress, and making adjustments as needed to address any deviations from the plan.[1]

**Project Scheduling:**

**1. Gantt Chart:**
- **Definition:** A Gantt Chart is a visual representation of a project schedule, showing the start and finish dates of various project tasks and milestones.[1]
- **Use:** Helps in planning and tracking project activities, identifying dependencies, and visualizing the overall project timeline.[1]

**2. Critical Path Method (CPM):**
- **Definition:** CPM is a project management technique used to determine the longest path through a project, identifying tasks that are critical to the project's completion.[1]
- **Use:** Helps in identifying the minimum project duration and managing task dependencies to ensure timely project completion.[1]

**3. Program Evaluation and Review Technique (PERT):**
- **Definition:** PERT is a statistical tool used to analyze and represent the tasks involved in completing a project, incorporating uncertainty and estimating task durations.[1]
- **Use:** Helps in assessing project timelines and determining the probability of meeting deadlines based on estimated task durations.[1]

**4. Project Tracking:**
- **Definition:** Project tracking involves monitoring the progress of tasks, comparing actual progress against the planned schedule, and identifying any deviations.[1]
- **Use:** Ensures that the project stays on track by tracking milestones, updating schedules, and managing resources effectively.[1]

**5. Project Management Tools:**
- **Examples:** Microsoft Project, Jira, Trello.[1]
- **Use:** These tools provide functionalities for scheduling, tracking, and managing project tasks, resources, and timelines.[1]

***

## **EXPERIMENT NO. 07**

**Title:** Write test cases for black box testing

**Aim:** To learn how to write effective test cases for black box testing and utilize software tools to manage and execute these test cases.[1]

**System Software/Instruments/Equipment's Requirements:** (Not specified in document)[1]

**Theory:**

**Black Box Testing:** Black box testing is a testing method where the tester evaluates the functionality of an application without peering into its internal structures or workings. The focus is on validating the software against its requirements and specifications.[1]

**Test Cases for Black Box Testing:**
- **Purpose:** To ensure that the software functions as expected from an end-user perspective.[1]
- **Design:** Test cases are designed based on the requirements and specifications of the software, including functional and non-functional aspects.[1]
- **Types of Test Cases:**
  - Functional Test Cases: Validate specific functions and features of the application.[1]
  - Boundary Test Cases: Check the application's behavior at the edge of input ranges.[1]
  - Error Handling Test Cases: Verify how the application handles invalid inputs or errors.[1]

**Each test case should include:**
1. Test Case ID: A unique identifier for the test case.[1]
2. Test Description: A brief description of what the test case will verify.[1]
3. Preconditions: Any setup required before executing the test case.[1]
4. Test Steps: Detailed steps to execute the test case.[1]
5. Expected Result: The expected outcome of the test case.[1]
6. Actual Result: The actual outcome of the test case (to be filled in during execution).[1]
7. Status: Pass/Fail status of the test case.[1]

**Steps:**

1. **Introduction to Black Box Testing:**
   - Understand the fundamentals of black box testing, where the tester does not need to know the internal structure or code of the application.[1]
   - Learn about different types of black box testing techniques, such as equivalence partitioning, boundary value analysis, decision table testing, and state transition testing.[1]

2. **Setup and Configuration:**
   - Install and configure the chosen test management tool (e.g., TestRail, JIRA with Zephyr, or TestLink) on computers.[1]
   - Create a new project in the test management tool to start writing test cases.[1]

3. **Identify Test Scenarios:**
   - Based on the application's requirements and specifications, identify different test scenarios that need to be tested.[1]

4. **Write Test Cases:**
   - For each test scenario, write detailed test cases that include Test Case ID, Test Case Description, Preconditions, Test Steps, Expected Results, Actual Results, and Status.[1]

5. **Organize Test Cases:**
   - Group related test cases into test suites or sections based on functionality or module.[1]

6. **Execute Test Cases:**
   - Execute the written test cases manually, following the test steps provided.[1]
   - Record the actual results and mark the status of each test case (Pass, Fail, etc.).[1]

7. **Log Defects:**
   - For any failed test cases, log defects using a bug-tracking tool like JIRA or Bugzilla. Include steps to reproduce, screenshots, and other relevant details.[1]

8. **Generate Reports and Analyze:**
   - Generate test execution and defect reports using the test management tool.[1]
   - Analyze the result